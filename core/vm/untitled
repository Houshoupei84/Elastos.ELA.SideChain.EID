	
配置的地址

did 的创世hash 比对下，然后不允许。

TransferCrossChainAsset

	         88.51+3*6+3*4 = 118.51

    97.13    100.84+6*4=124.84


    		 100.84  12 = 112.84
    		 88.51   24	= 112.51		

	ownerPublicKeyStr1 := "02f981e4dae4983a5d284d01609ad735e3242c5672bb2c7bb0018cc36f9ab0c4a5"
	ownerPrivateKeyStr1 := "15e0947580575a9b6729570bed6360a890f84a07dc837922fe92275feec837d4"
	crPublicKeyStr := "036db5984e709d2e0ec62fd974283e9a18e7b87e8403cc784baf1f61f775926535"
	crPrivateKeyStr := "b2c25e877c8a87d54e8a20a902d27c7f24ed52810813ba175ca4e8d3036d130e"
	secretaryPublicKeyStr := "031e12374bae471aa09ad479f66c2306f4bcc4ca5b754609a82a1839b94b4721b9"
	secretaryPrivateKeyStr := "94396a69462208b8fd96d83842855b867d3b0e663203cb31d0dfaec0362ec034"
	//recipent, draftData are all random data so hash is changing all the time
	txn := s.getSecretaryGeneralCRCProposalTx(ownerPublicKeyStr1, ownerPrivateKeyStr1, crPublicKeyStr, crPrivateKeyStr,
		secretaryPublicKeyStr, secretaryPrivateKeyStr)


	signBuf := new(bytes.Buffer)
	crcProposalPayload.SerializeUnsigned(signBuf, payload.CRCProposalVersion)
	sig, _ := crypto.Sign(ownerPrivateKey, signBuf.Bytes())
	crcProposalPayload.Signature = sig

	crcProposalPayload.CRCouncilMemberDID.Serialize(signBuf)
	crSig, _ := crypto.Sign(crPrivateKey, signBuf.Bytes())
	crcProposalPayload.CRCouncilMemberSignature = crSig


















	// 0x02 code upgrade related proposals.
	// MainChainUpgradeCode indicates the ELA code upgrade types of proposals.
	MainChainUpgradeCode CRCProposalType = 0x0200
	// DIDUpgradeCode indicates the DID code upgrade types of proposals.
	DIDUpgradeCode CRCProposalType = 0x0201
	// DIDUpgradeCode indicates the ETH code upgrade types of proposals.
	ETHUpgradeCode CRCProposalType = 0x0202




		tx := &types.Transaction{
			Version: types.TxVersion09,
			TxType:  types.CustomIDResult,
			Payload: &payload.CustomIDProposalResult{
				ProposalResults: c.CustomIDProposalResults,
			},
			Attributes: []*types.Attribute{},
			Programs:   []*program.Program{},
			LockTime:   0,
		}	



		type CustomIDProposalResult struct {
			ProposalResults []ProposalResult
		}






	type UpgradeCodeInfo struct {
	//upgrade code working hegiht
	WorkingHeight uint32

	//node version
	NodeVersion string

	//node bin download url
	NodeDownLoadUrl string

	//node bin hash
	NodeBinHash *common.Uint256

	// if ForceUpgrade is true when height reaches WorkingHeight
	// version of msg.Version must greater or equal to NodeVersion
	ForceUpgrade bool
}


这个高度是否需要配置
ProposalPublicVotingPeriod:  7 * 720,



//todo add process
	if payload.IsUpgradeCodeProposal(proposalState.Proposal.ProposalType) {
		p.UpgradCodeProposalMgr[]
	}






history.Append(height, func() {
		hash := proposal.Hash(tx.PayloadVersion)
		log.Debug("registerProposal hash", hash.String())
		p.Proposals[hash] = proposalState
		p.addProposal(crCouncilMemberDID, hash)
		if _, ok := p.ProposalSession[currentsSession]; !ok {
			p.ProposalSession[currentsSession] = make([]common.Uint256, 0)
		}
		p.ProposalSession[currentsSession] =
			append(p.ProposalSession[currentsSession], proposal.Hash(tx.PayloadVersion))
	}, func() {
		delete(p.Proposals, proposal.Hash(tx.PayloadVersion))
		p.delProposal(crCouncilMemberDID, hash)
		if len(p.ProposalSession[currentsSession]) == 1 {
			delete(p.ProposalSession, currentsSession)
		} else {
			count := len(p.ProposalSession[currentsSession])
			p.ProposalSession[currentsSession] = p.ProposalSession[currentsSession][:count-1]
		}
	})












1. 是不是那几个提案类型是确定的不能改变的。
2. 同一个升级提案类型 一个块只能有一个。
3. node version format v0.1.2
4. 是否需要排序，按照working height sort or nodeversion(workingheight >14天)
5. 如果异常事件发生一个错误版本通过怎么办（可能是版本号错误，生效高度错误，或者其他错误）,
增加一个取消版本的交易能快速触发？




ProposalSession map[uint64][]common.Uint256




	CRCProposalUpgradeCodeHeight = cli.StringFlag{
		Name:  "crcproposalupgradcodeheight",
		Usage: "defines the upgrade code height ",
	}


	//todo add process
	if payload.IsUpgradeCodeProposal(proposalState.Proposal.ProposalType) {
		123
	}



	if err := common.WriteUint32(w, n.WorkingHeight); err != nil {
		return err
	}

	var workingHeight uint32
	if workingHeight, err = common.ReadUint32(r); err != nil {
		return err
	}
	n.WorkingHeight = workingHeight

